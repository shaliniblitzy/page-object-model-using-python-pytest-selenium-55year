# Kubernetes Deployment for Storydoc Test Automation Framework

## Introduction

This document provides comprehensive instructions for deploying, configuring, and managing the Storydoc test automation framework in a Kubernetes environment. The framework is designed to automate testing of core user flows including registration, authentication, story creation, and sharing in the Storydoc application.

## Prerequisites

- Kubernetes cluster (version 1.19+)
- kubectl CLI tool installed and configured
- Access to a container registry for storing the framework image
- Basic understanding of Kubernetes concepts

## Kubernetes Resources Overview

The deployment uses the following Kubernetes resources:

- **Namespace**: Isolates the test automation resources from other applications
- **Deployment**: Manages the pods running the test automation framework
- **Service**: Provides access to the test reporting interface
- **ConfigMap**: Stores non-sensitive configuration parameters
- **Secret**: Securely stores sensitive data like API keys and credentials

## Deployment Instructions

### 1. Create Namespace

First, create a dedicated namespace for the test automation framework:

```yaml
# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: storydoc-automation
```

Apply the namespace:

```bash
kubectl apply -f namespace.yaml
```

### 2. Configure Non-Sensitive Settings

Create a ConfigMap to store non-sensitive configuration:

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: storydoc-automation-config
  namespace: storydoc-automation
data:
  BASE_URL: "https://editor-staging.storydoc.com"
  DEFAULT_TIMEOUT: "10"
  HEADLESS_MODE: "true"
  TEST_EMAIL_DOMAIN: "mailinator.com"
  SCREENSHOT_DIR: "/app/reports/screenshots"
  REPORT_DIR: "/app/reports/html"
```

Apply the ConfigMap:

```bash
kubectl apply -f configmap.yaml
```

### 3. Configure Secrets

For sensitive information, create a Kubernetes Secret:

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: storydoc-automation-secrets
  namespace: storydoc-automation
type: Opaque
data:
  # Base64 encoded values
  TEST_USER_PASSWORD: VGVzdEAxMjM=  # Test@123
  MAILINATOR_API_KEY: eW91ci1hcGkta2V5  # your-api-key
```

To create base64 encoded values:

```bash
echo -n "Test@123" | base64
echo -n "your-api-key" | base64
```

Apply the Secret:

```bash
kubectl apply -f secret.yaml
```

### 4. Create Deployment

Create a deployment to run the test automation framework:

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: storydoc-automation
  namespace: storydoc-automation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: storydoc-automation
  template:
    metadata:
      labels:
        app: storydoc-automation
    spec:
      containers:
      - name: automation-framework
        image: your-registry/storydoc-automation:latest
        resources:
          requests:
            memory: "1Gi"
            cpu: "0.5"
          limits:
            memory: "2Gi"
            cpu: "1"
        envFrom:
        - configMapRef:
            name: storydoc-automation-config
        - secretRef:
            name: storydoc-automation-secrets
        ports:
        - containerPort: 8000
          name: report-server
        volumeMounts:
        - name: reports
          mountPath: /app/reports
      volumes:
      - name: reports
        emptyDir: {}
```

Apply the deployment:

```bash
kubectl apply -f deployment.yaml
```

### 5. Create Service for Reporting Interface

Create a service to expose the test reporting interface:

```yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: storydoc-automation-service
  namespace: storydoc-automation
spec:
  selector:
    app: storydoc-automation
  ports:
  - port: 8000
    targetPort: report-server
  type: ClusterIP
```

Apply the service:

```bash
kubectl apply -f service.yaml
```

### 6. Verify Deployment

Verify that all resources have been created correctly:

```bash
kubectl get all -n storydoc-automation
```

## Accessing Test Reports

There are several ways to access the test reports generated by the framework:

### Option 1: Port Forwarding

Use kubectl port-forward to temporarily access the reports:

```bash
# Get the pod name
kubectl get pods -n storydoc-automation

# Set up port forwarding
kubectl port-forward <pod-name> 8000:8000 -n storydoc-automation
```

Then open http://localhost:8000 in your web browser.

### Option 2: Ingress (for permanent access)

Create an Ingress resource for permanent external access to the reports:

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: storydoc-automation-ingress
  namespace: storydoc-automation
spec:
  rules:
  - host: automation-reports.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: storydoc-automation-service
            port:
              number: 8000
```

Apply the Ingress:

```bash
kubectl apply -f ingress.yaml
```

### Option 3: Downloading Reports

You can download the report files directly from the pod:

```bash
# Get the pod name
kubectl get pods -n storydoc-automation

# Copy reports to local machine
kubectl cp <pod-name>:/app/reports/html ./local-reports -n storydoc-automation
```

## CI/CD Integration

To integrate the Kubernetes deployment with CI/CD pipelines:

### GitHub Actions Example

```yaml
name: Storydoc Automation Tests

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v1
      
    - name: Set Kubernetes context
      uses: azure/k8s-set-context@v1
      with:
        kubeconfig: ${{ secrets.KUBE_CONFIG }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v2
      with:
        context: .
        push: true
        tags: your-registry/storydoc-automation:${{ github.sha }}
    
    - name: Update deployment image
      run: |
        kubectl set image deployment/storydoc-automation automation-framework=your-registry/storydoc-automation:${{ github.sha }} -n storydoc-automation
    
    - name: Wait for tests to complete
      run: |
        kubectl rollout status deployment/storydoc-automation -n storydoc-automation
        # Add additional logic to wait for tests to complete
    
    - name: Retrieve test results
      run: |
        POD=$(kubectl get pods -n storydoc-automation -l app=storydoc-automation -o jsonpath="{.items[0].metadata.name}")
        kubectl cp $POD:/app/reports/html ./test-reports -n storydoc-automation
    
    - name: Upload test results
      uses: actions/upload-artifact@v2
      with:
        name: test-reports
        path: ./test-reports
```

### Jenkins Pipeline Example

```groovy
pipeline {
    agent any
    
    stages {
        stage('Build Image') {
            steps {
                sh 'docker build -t your-registry/storydoc-automation:${BUILD_NUMBER} .'
                sh 'docker push your-registry/storydoc-automation:${BUILD_NUMBER}'
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                sh 'kubectl set image deployment/storydoc-automation automation-framework=your-registry/storydoc-automation:${BUILD_NUMBER} -n storydoc-automation'
                sh 'kubectl rollout status deployment/storydoc-automation -n storydoc-automation'
            }
        }
        
        stage('Wait for Tests') {
            steps {
                // Add logic to wait for tests to complete
                sh 'sleep 300'  // Simple example - wait 5 minutes
            }
        }
        
        stage('Collect Results') {
            steps {
                sh '''
                POD=$(kubectl get pods -n storydoc-automation -l app=storydoc-automation -o jsonpath="{.items[0].metadata.name}")
                kubectl cp $POD:/app/reports/html ./test-reports -n storydoc-automation
                '''
                
                archiveArtifacts artifacts: 'test-reports/**', allowEmptyArchive: true
            }
        }
    }
}
```

## Scaling the Deployment

To scale the test automation deployment:

### Option 1: Update the Deployment YAML

Modify the `replicas` value in deployment.yaml and apply the changes:

```yaml
spec:
  replicas: 3  # Change to desired number
```

Apply the updated deployment:

```bash
kubectl apply -f deployment.yaml
```

### Option 2: Use kubectl scale command

Directly scale the deployment using kubectl:

```bash
kubectl scale deployment storydoc-automation --replicas=3 -n storydoc-automation
```

### Considerations for Scaling

When scaling the test automation framework:

1. **Resource Allocation**: Ensure your Kubernetes cluster has sufficient resources
2. **Test Isolation**: Consider how multiple instances might affect shared resources
3. **Report Aggregation**: Implement a strategy to aggregate test reports from multiple pods

## Resource Requirements

The Storydoc test automation framework has the following resource requirements in Kubernetes:

| Resource | Minimum | Recommended |
|----------|---------|-------------|
| CPU      | 0.5 cores | 1 core    |
| Memory   | 1Gi     | 2Gi        |
| Storage  | 500Mi   | 1Gi        |

These requirements assume:
- Headless browser operation
- Standard test suite execution
- Report generation and storage

For parallel test execution or larger test suites, increase resources accordingly.

## Troubleshooting

### Common Issues and Solutions

| Issue | Possible Cause | Solution |
|-------|---------------|----------|
| Pod stuck in Pending state | Insufficient cluster resources | Check available resources with `kubectl describe node` |
| CrashLoopBackOff | Application error or misconfiguration | Check logs with `kubectl logs <pod-name> -n storydoc-automation` |
| Tests failing due to timeouts | Network latency or resource constraints | Increase timeout values in ConfigMap and/or increase pod resources |
| Cannot access test reports | Service or port forwarding issues | Verify service is running with `kubectl get svc -n storydoc-automation` |
| Tests failing due to authentication | Incorrect or missing secrets | Verify secrets are correctly configured |

### Useful Diagnostic Commands

```bash
# Check pod status
kubectl get pods -n storydoc-automation

# View pod logs
kubectl logs <pod-name> -n storydoc-automation

# Get detailed pod information
kubectl describe pod <pod-name> -n storydoc-automation

# Check ConfigMap and Secret content (shows non-sensitive info)
kubectl describe configmap storydoc-automation-config -n storydoc-automation
kubectl describe secret storydoc-automation-secrets -n storydoc-automation

# Shell into the pod for debugging
kubectl exec -it <pod-name> -n storydoc-automation -- /bin/sh

# Check resource usage
kubectl top pod <pod-name> -n storydoc-automation
```

## Best Practices

1. **Use namespaces** to isolate testing resources from production
2. **Implement resource limits** to prevent runaway tests from consuming all cluster resources
3. **Store test artifacts** using PersistentVolumes for important test runs
4. **Integrate with monitoring** to track test execution trends over time
5. **Use image tags** rather than `latest` for reproducible test runs
6. **Implement proper secret management** for sensitive credentials
7. **Keep test pods short-lived** to avoid resource accumulation
8. **Consider using Jobs or CronJobs** for scheduled test execution

## Conclusion

This documentation provides a comprehensive guide for deploying and managing the Storydoc test automation framework in a Kubernetes environment. By following these instructions, you can set up a robust, scalable testing infrastructure that integrates with your CI/CD pipeline.

For additional assistance or to report issues, please contact the DevOps team or create an issue in the project repository.